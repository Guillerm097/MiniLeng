/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  ignore_case = true;
  static = true;
}

PARSER_BEGIN(MiniLeng)

package main;
import java.util.LinkedList;
import lexico.LexicoUtils;
import sintactico.SintacticoUtils;
import static sintactico.SintacticoUtils.error_sintactico;
import semantico.*;
import static semantico.SemanticoUtils.error_semantico;
import semantico.Simbolo.Tipo_variable;
import semantico.SemanticoUtils.Tipo_operador;
import semantico.SemanticoUtils.ExprRegister;


public class MiniLeng
{
  static Tabla_simbolos ts = new Tabla_simbolos();
  
  public static void main(String args []) throws ParseException
  {
    MiniLeng parser;

	//boolean flagsv = args[args.length - 2].equals("flags") && args[args.length - 1].equals("-v");
	boolean flagsv = false;
    
    if (args.length == 0 || (args.length == 2 && flagsv)) {
      parser = new MiniLeng(System.in);
  	}
  	else if (args.length == 1 || (args.length == 3 && flagsv)) {
  	  try {
          parser = new MiniLeng(new java.io.FileInputStream(args[0]));
      }
      catch(java.io.FileNotFoundException e) {
        System.out.println ("MiniLeng: The file " + args[0] + " was not found.");
        return;
      }
	}
	      
   	try
    {
      //MiniLeng.one_line();
      
	  MiniLeng.programa();

      if (flagsv) {
        LexicoUtils.mostrarTabla();
      }
   	}
    catch (Error e) { // ERRORES LEXICOS
      	LexicoUtils.mostrarErrorLexico(MiniLengTokenManager.input_stream.getBeginLine(),
      									MiniLengTokenManager.input_stream.getBeginColumn(),
      									MiniLengTokenManager.curChar);
    }
  }  
}


PARSER_END(MiniLeng)

SKIP :
{
  " "
| "%%" : WithinBlockComment
| "%" : WithinLineComment
| "\r"
| "\t"
| "\n"
}

<WithinBlockComment> SKIP :
{
  "%%" : DEFAULT
}

<WithinBlockComment> MORE :
{
  < ~[] >
}

<WithinLineComment> SKIP :
{
  "\n" : DEFAULT
}

<WithinLineComment> MORE :
{
  < ~[] >
}

TOKEN: /* PALABRAS RESERVADAS */
{
  < tVAL : "val" >			 {  LexicoUtils.anyadirToken("palabra reservada"); }
| < tREF : "ref" > 			 {  LexicoUtils.anyadirToken("palabra reservada"); }
| < tLEER : "leer" >		 {  LexicoUtils.anyadirToken("palabra reservada"); }
| < tTRUE : "true" >		 {  LexicoUtils.anyadirToken("palabra reservada"); }
| < tFALSE : "false" >		 {  LexicoUtils.anyadirToken("palabra reservada"); }
| < tACCION : "accion" >	 {  LexicoUtils.anyadirToken("palabra reservada"); }
| < tENTERO : "entero" >	 {  LexicoUtils.anyadirToken("palabra reservada");
								LexicoUtils.anyadirToken("entero"); 			  }
| < tENTACAR : "entacar" >	 {  LexicoUtils.anyadirToken("palabra reservada"); }
| < tCARAENT : "caraent" > 	 {  LexicoUtils.anyadirToken("palabra reservada"); }	
| < tBOOLEANO : "booleano" > {  LexicoUtils.anyadirToken("palabra reservada");
								LexicoUtils.anyadirToken("booleano"); 		  }
| < tCARACTER : "caracter" > {  LexicoUtils.anyadirToken("palabra reservada");
								LexicoUtils.anyadirToken("caracter"); 		  }
| < tESCRIBIR : "escribir" > {  LexicoUtils.anyadirToken("palabra reservada"); }
| < tPROGRAMA : "programa" > {  LexicoUtils.anyadirToken("palabra reservada"); }
}

TOKEN : /* PALABRAS RESERVADAS CONTROL FLUJO */
{
  < tSI : "si" >	{  LexicoUtils.anyadirToken("palabra reservada"); }
| < tMQ : "mq" >	{  LexicoUtils.anyadirToken("palabra reservada"); }
| < tFIN : "fin" >	{  LexicoUtils.anyadirToken("palabra reservada"); }
| < tENT : "ent" >	{  LexicoUtils.anyadirToken("palabra reservada"); }
| < tFSI : "fsi" >	{  LexicoUtils.anyadirToken("palabra reservada"); }
| < tFMQ : "fmq" >	{  LexicoUtils.anyadirToken("palabra reservada"); }
| < tSI_NO : "si_no" >	{  LexicoUtils.anyadirToken("palabra reservada"); }
| < tPRINCIPIO : "principio" >	{  LexicoUtils.anyadirToken("palabra reservada"); }
}

TOKEN : /* OPERATORS */
{
  < tPLUS : "+" >		{  LexicoUtils.anyadirToken("operador"); }
| < tMINUS : "-" >		{  LexicoUtils.anyadirToken("operador"); }
| < tMULTIPLY : "*" >	{  LexicoUtils.anyadirToken("operador"); }
| < tDIVIDE : "/" >		{  LexicoUtils.anyadirToken("operador"); }
| < tMAYOR : ">" >		{  LexicoUtils.anyadirToken("operador"); }
| < tMENOR : "<" >		{  LexicoUtils.anyadirToken("operador"); }
| < tIGUAL : "=" >		{  LexicoUtils.anyadirToken("operador"); }
| < tMAI : ">=" >		{  LexicoUtils.anyadirToken("operador"); }
| < tMEI : "<=" >		{  LexicoUtils.anyadirToken("operador"); }
| < tNI : "<>" > 		{  LexicoUtils.anyadirToken("operador"); }
| < tOPAS : ":=" >		{  LexicoUtils.anyadirToken("operador"); }
| < tOR : "or" >		{  LexicoUtils.anyadirToken("operador"); }
| < tAND : "and" >		{  LexicoUtils.anyadirToken("operador"); }
| < tNOT : "not" >		{  LexicoUtils.anyadirToken("operador"); }
| < tMOD : "mod" >		{  LexicoUtils.anyadirToken("operador"); }
| < tDIV : "div" >		{  LexicoUtils.anyadirToken("operador"); }
}

TOKEN : /* SEPARADORES Y AGRUPADORES */
{
  < tPC : ";" >
| < tC  : "," >
| < tAP : "(" >
| < tCP : ")" >
}

TOKEN : /* TOKENS NO CONSTANTES */
{

 < tCONSTCHAR : "\"" ~["\""] "\"" >
| < tCONSTCAD : "\"" (~["\""])* "\"" >
| < tCONSTENTERA : (< DIGIT >)+ >
| < tIDENTIFICADOR : (< LETTER >) | ((< LETTER > | "_") (< LETTER > | < DIGIT > |  "_" )* (< LETTER > | < DIGIT >)) >
  {  LexicoUtils.anyadirToken("identificador"); }
| < #DIGIT : [ "0"-"9" ] >
| < #LETTER : [ "a"-"z", "A"-"Z" ] >

}
/*
int one_line() :
{}
{
(
< tPROGRAMA>
| < tENTERO >
| < tBOOLEANO >
| < tCARACTER >
| < tTRUE >
| < tFALSE >
| < tENTACAR >
| < tCARAENT >
| < tACCION > 
| < tVAL >
| < tREF >
| < tESCRIBIR >
| < tLEER >
| < tPRINCIPIO >
| < tFIN >
| < tSI >
| < tENT >
| < tSI_NO >
| < tFSI >
| < tMQ >
| < tFMQ >
| < tPLUS >
| < tMINUS >
| < tMULTIPLY >
| < tDIVIDE >
| < tMAYOR >
| < tMENOR >
| < tIGUAL >
| < tMAI >
| < tMEI >
| < tNI > 
| < tOPAS >
| < tAND >
| < tOR >
| < tNOT >
| < tMOD >
| < tDIV >
| < tPC >
| < tC >
| < tAP >
| < tCP >
| < tIDENTIFICADOR >
| < tCONSTENTERA >
| < tCONSTCAD >
| < tCONSTCHAR >
| < EOF > { return 1; }
)+
}*/

// <tPROGRAMA> <tIDENTIFICADOR> ";"
void programa() :
{}
{
  try {
	<tPROGRAMA> <tIDENTIFICADOR> ";"
	declaracion_variables() declaracion_acciones() bloque_sentencias() < EOF >
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

    Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// (declaracion() ";")*
void declaracion_variables() :
{}
{
  try {
  	(declaracion() ";")*
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// tipo_variables() identificadores()
void declaracion() :
{
	Tipo_variable tv;
}
{
  try {
    tv = tipo_variables()
	identificadores(tv)
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

/*	  < tENTERO >
	| < tCARACTER >
	| < tBOOLEANO >
*/
Tipo_variable tipo_variables() :
{}
{
  try { 
	  < tENTERO > { return Tipo_variable.ENTERO; }
	| < tCARACTER > { return Tipo_variable.CHAR; }
	| < tBOOLEANO > { return Tipo_variable.BOOLEANO; }
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// < tIDENTIFICADOR > ("," < tIDENTIFICADOR >)*
void identificadores(Tipo_variable tipo) :
{
  Token t1 = null;
}
{
  try {
    t1 = < tIDENTIFICADOR >
    {
      if(ts.buscar_simbolo(t1.image) == null) {
		ts.introducir_variable(t1.image, tipo, ts.getNivel(), 0); //TODO: Cambiar el dir
      }
    }
    ("," < tIDENTIFICADOR >)*
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);
	
	Token t;
	do {
	   t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
  catch(SimboloNoEncontradoException e) {
    System.out.println(e);
  }
}

// (declaracion_accion())*
void declaracion_acciones() :
{}
{
  try { 
  	(declaracion_accion())*
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// cabecera_accion() ";" declaracion_variables() declaracion_acciones() bloque_sentencias()
void declaracion_accion() :
{}
{
  try { 
	cabecera_accion() ";" declaracion_variables() declaracion_acciones() bloque_sentencias()
	{
	  	int nivel = ts.getNivel();
	  	ts.eliminar_variables(nivel);
	  	ts.eliminar_acciones(nivel);
	  	ts.eliminar_parametros_ocultos(nivel + 1);
		nivel--;
	}
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// < tACCION > <tIDENTIFICADOR > parametros_formales()
void cabecera_accion() :
{
  Token to;
  Simbolo s;
  boolean ok;
  LinkedList <Simbolo> lista_param;
}
{
  try { 
  	< tACCION >
  	to = < tIDENTIFICADOR >
  	{
  	  int nivel = ts.getNivel();
  	  int dir = ts.getDir();
  	  s = ts.buscar_simbolo(to.image);
  	  if ((s == null) || (s.getNivel() != nivel)) {
		ts.introducir_accion(to.image, nivel, dir);
		ok = true;
  	  }
  	  else {
		error_semantico("Identificador duplicado");
		ok = false;
  	  }
  	}
  	
  	lista_param = parametros_formales()
  	{
  	  if (ok) {
  	    s.setLista_parametros(lista_param);	// TODO: ¿Se guardan bien? guardar en la tabla los parametros formales como variables
  	  }
  	}
  	
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// ("(" parametros() ")")?
LinkedList<Simbolo> parametros_formales() :
{
  LinkedList<Simbolo> ls;
}
{
  try {
    ("(" parametros() ")")?
    {
      	ls = null; // TODO: IR AÑADIENDO CADA PARAMETRO (COMPROBAR MUCHAS COSITAS NAZIS)
		return ls;
	}
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// < tIDENTIFICADOR > (";" parametros())*
void lista_parametros() :
{}
{
  try {
    < tIDENTIFICADOR > (";" parametros())*
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// clase_parametros() tipo_variables() lista_parametros()
void parametros() :
{}
{
  try { 
  	clase_parametros() tipo_variables() lista_parametros()
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

/*
	< tVAL >
    | < tREF >
*/
void clase_parametros() :
{}
{
  try {
    < tVAL >
    | < tREF >
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// < tPRINCIPIO > lista_sentencias() < tFIN >
void bloque_sentencias() :
{}
{
  try {
    < tPRINCIPIO > lista_sentencias() < tFIN >
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// (sentencia())*
void lista_sentencias() :
{}
{
  try {
    (sentencia())*
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

/*
	leer() ";"
	| escribir() ";"
	| < tIDENTIFICADOR > (resto_asignacion() | resto_invocacion_accion()) // Hay que factorizar
	| seleccion()
	| mientras_que()
*/
void sentencia() :
{}
{
  try {
	  leer() ";"
	| escribir() ";"
	| < tIDENTIFICADOR > (resto_asignacion() | resto_invocacion_accion()) // Hay que factorizar
	| seleccion()
	| mientras_que()
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// < tOPAS > expresion() ";"
void resto_asignacion() :
{}
{
  try {
    < tOPAS > expresion() ";"
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// (argumentos())? ";"
void resto_invocacion_accion() :
{}
{
  try {
    (argumentos())? ";"
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// < tLEER > "(" lista_asignables() ")"
void leer() :
{}
{
  try {
    < tLEER > "(" lista_asignables() ")"
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// < tIDENTIFICADOR > ("," < tIDENTIFICADOR >)*
void lista_asignables() :
{}
{
  try {
    < tIDENTIFICADOR > ("," < tIDENTIFICADOR >)*
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

//  tESCRIBIR >  "(" lista_escribibles()  ("," lista_escribibles())* ")"
void escribir() :
{}
{
  try {
    < tESCRIBIR >  "(" lista_escribibles()  ("," lista_escribibles())* ")"
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

/*
	< tIDENTIFICADOR >
	| < tCONSTCHAR >
	| < tCONSTCAD >
	| < tENTACAR >  "(" < tCONSTENTERA > ")"
*/
void lista_escribibles() :
{}
{
  try {
	  < tIDENTIFICADOR >
	| < tCONSTCHAR >
	| < tCONSTCAD >
	| < tENTACAR >  "(" < tCONSTENTERA > ")"
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// < tIDENTIFICADOR > < tOPAS > expresion() ";"
void asignacion() :
{}
{
  try {
    < tIDENTIFICADOR > < tOPAS > expresion() ";"
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// < tIDENTIFICADOR > (argumentos())? ";"
void invocacion_accion() :
{}
{
  try {
  	< tIDENTIFICADOR > (argumentos())? ";"
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// < tMQ > expresion() lista_sentencias() < tFMQ >
void mientras_que() :
{}
{
  try {
  	< tMQ > expresion() lista_sentencias() < tFMQ >
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

/*
	< tSI > expresion() < tENT > lista_sentencias()
	(< tSI_NO > lista_sentencias())*
	< tFSI >
*/
void seleccion() :
{}
{
  try {
	< tSI > expresion() < tENT > lista_sentencias()
	(< tSI_NO > lista_sentencias())*
	< tFSI >
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// "(" (lista_expresiones())? ")"
void argumentos() :
{}
{
  try {
    "(" (lista_expresiones())? ")"
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// (expresion())+
void lista_expresiones() :
{}
{
  try {
  	(expresion())+
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// expresion_simple() (operador_relacional() expresion_simple())*
ExprRegister expresion() :
{
  ExprRegister exprIzq, exprDer, resultado;
  Tipo_variable varExprIzq, varExprDer;
  Tipo_operador op;
  boolean ok;
}
{
  try {
    exprIzq = expresion_simple()
    op = operador_relacional()
    exprDer = expresion_simple()
    {
      	resultado = new ExprRegister();
		varExprIzq = exprIzq.tipo;
      	varExprDer = exprDer.tipo;
      	
  	  	ok = true;
		switch(op) {
	  		case SUMA:
	  			if ((varExprIzq != Tipo_variable.ENTERO)
	  				&& (varExprIzq != Tipo_variable.DESCONOCIDO)) {
	  				error_semantico("El miembro izquierdo de la expresión debería ser de tipo entero");
					ok = false;
	  			}
	
				if ((varExprDer != Tipo_variable.ENTERO)
	  				&& (varExprDer != Tipo_variable.DESCONOCIDO)) {
					error_semantico("El miembro derecho de la expresión debería ser de tipo entero");
					ok = false;
	  			}
	
	  			if (ok) {
	  			  	if ((varExprDer == Tipo_variable.ENTERO)
	  			  	  	&& (varExprIzq == Tipo_variable.ENTERO)) {
		  			  	resultado.val_entero = exprIzq.val_entero + exprDer.val_entero;
						resultado.tipo = Tipo_variable.ENTERO;
					}
					else {
						resultado.tipo = Tipo_variable.DESCONOCIDO;
					}
	  			}
	  			
	  			return resultado;
	  			
	  		case RESTA:
				if ((varExprIzq != Tipo_variable.ENTERO)
	  				&& (varExprIzq != Tipo_variable.DESCONOCIDO)) {
	  				error_semantico("El miembro izquierdo de la expresión debería ser de tipo entero");
					ok = false;
	  			}
	
				if ((varExprDer != Tipo_variable.ENTERO)
	  				&& (varExprDer != Tipo_variable.DESCONOCIDO)) {
					error_semantico("El miembro derecho de la expresión debería ser de tipo entero");
					ok = false;
	  			}
	
	  			if (ok) {
	  			  	if ((varExprDer == Tipo_variable.ENTERO)
	  			  	  	&& (varExprIzq == Tipo_variable.ENTERO)) {
		  			  	resultado.val_entero = exprIzq.val_entero - exprDer.val_entero;
						resultado.tipo = Tipo_variable.ENTERO;
					}
					else {
						resultado.tipo = Tipo_variable.DESCONOCIDO;
					}
	  			}
	  			
	  			return resultado;
	
	  		case OR:
				if ((varExprIzq != Tipo_variable.BOOLEANO)
	  				&& (varExprIzq != Tipo_variable.DESCONOCIDO)) {
	  				error_semantico("El miembro izquierdo de la expresión debería ser de tipo booleano");
					ok = false;
	  			}
	
				if ((varExprDer != Tipo_variable.BOOLEANO)
	  				&& (varExprDer != Tipo_variable.DESCONOCIDO)) {
					error_semantico("El miembro derecho de la expresión debería ser de tipo booleano");
					ok = false;
	  			}
	
	  			if (ok) {
	  			  	if ((varExprDer == Tipo_variable.BOOLEANO)
	  			  	  	&& (varExprIzq == Tipo_variable.BOOLEANO)) {
		  			  	resultado.val_booleano = exprIzq.val_booleano | exprDer.val_booleano;
						resultado.tipo = Tipo_variable.BOOLEANO;
					}
					else {
						resultado.tipo = Tipo_variable.DESCONOCIDO;
					}
	  			}
	  			
	  			return resultado;	
      	}
    }
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

/*
	  < tMAYOR >
	| < tMENOR >
	| < tIGUAL >
	| < tMAI >
	| < tMEI >
	| < tNI >
*/
void operador_relacional() :
{}
{
  try {
	  < tMAYOR >
	| < tMENOR >
	| < tIGUAL >
	| < tMAI >
	| < tMEI >
	| < tNI >
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// termino() (operador_aditivo() termino())* 
ExprRegister expresion_simple() :
{
  ExprRegister exprIzq, exprDer, resultado;
  Tipo_operador op;
  boolean ok;
}
{
  try {
    exprIzq =termino()
    (
      op =operador_aditivo()
      exprDer = termino()
    )*
    {
      	resultado = new ExprRegister();
		varExprIzq = exprIzq.tipo;
      	varExprDer = exprDer.tipo;
      	
  	  	ok = true;
		switch(op) {
	  		case SUMA:
	  			if ((varExprIzq != Tipo_variable.ENTERO)
	  				&& (varExprIzq != Tipo_variable.DESCONOCIDO)) {
	  				error_semantico("El miembro izquierdo de la expresión debería ser de tipo entero");
					ok = false;
	  			}
	
				if ((varExprDer != Tipo_variable.ENTERO)
	  				&& (varExprDer != Tipo_variable.DESCONOCIDO)) {
					error_semantico("El miembro derecho de la expresión debería ser de tipo entero");
					ok = false;
	  			}
	
	  			if (ok) {
	  			  	if ((varExprDer == Tipo_variable.ENTERO)
	  			  	  	&& (varExprIzq == Tipo_variable.ENTERO)) {
		  			  	resultado.val_entero = exprIzq.val_entero + exprDer.val_entero;
						resultado.tipo = Tipo_variable.ENTERO;
					}
					else {
						resultado.tipo = Tipo_variable.DESCONOCIDO;
					}
	  			}
	  			
	  			return resultado;
	  			
	  		case RESTA:
				if ((varExprIzq != Tipo_variable.ENTERO)
	  				&& (varExprIzq != Tipo_variable.DESCONOCIDO)) {
	  				error_semantico("El miembro izquierdo de la expresión debería ser de tipo entero");
					ok = false;
	  			}
	
				if ((varExprDer != Tipo_variable.ENTERO)
	  				&& (varExprDer != Tipo_variable.DESCONOCIDO)) {
					error_semantico("El miembro derecho de la expresión debería ser de tipo entero");
					ok = false;
	  			}
	
	  			if (ok) {
	  			  	if ((varExprDer == Tipo_variable.ENTERO)
	  			  	  	&& (varExprIzq == Tipo_variable.ENTERO)) {
		  			  	resultado.val_entero = exprIzq.val_entero - exprDer.val_entero;
						resultado.tipo = Tipo_variable.ENTERO;
					}
					else {
						resultado.tipo = Tipo_variable.DESCONOCIDO;
					}
	  			}
	  			
	  			return resultado;
	
	  		case OR:
				if ((varExprIzq != Tipo_variable.BOOLEANO)
	  				&& (varExprIzq != Tipo_variable.DESCONOCIDO)) {
	  				error_semantico("El miembro izquierdo de la expresión debería ser de tipo booleano");
					ok = false;
	  			}
	
				if ((varExprDer != Tipo_variable.BOOLEANO)
	  				&& (varExprDer != Tipo_variable.DESCONOCIDO)) {
					error_semantico("El miembro derecho de la expresión debería ser de tipo booleano");
					ok = false;
	  			}
	
	  			if (ok) {
	  			  	if ((varExprDer == Tipo_variable.BOOLEANO)
	  			  	  	&& (varExprIzq == Tipo_variable.BOOLEANO)) {
		  			  	resultado.val_booleano = exprIzq.val_booleano | exprDer.val_booleano;
						resultado.tipo = Tipo_variable.BOOLEANO;
					}
					else {
						resultado.tipo = Tipo_variable.DESCONOCIDO;
					}
	  			}
	  			
	  			return resultado;
      	}
    }
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

/*
	  "+"
	| "-"
	| < tOR >
*/
Tipo_operador operador_aditivo() :
{}
{
  try {
	  "+" 		{ return Tipo_operador.SUMA; }
	| "-"		{ return Tipo_operador.RESTA; }
	| < tOR >	{ return Tipo_operador.OR; }
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

// factor() (operador_multiplicativo() termino())*
void termino() :
{}
{
  try {
    factor() (operador_multiplicativo() factor())* // TODO: El ultimo es factor() o termino(); DIAP 21, SEMANTICO III
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

/*
	  "*"
	| "/"
	| < tDIV >
	| < tMOD >
	| < tAND >
*/
void operador_multiplicativo() :
{}
{
  try {
	  "*"
	| "/"
	| < tDIV >
	| < tMOD >
	| < tAND >
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}

/*
 "-" factor()
	| < tNOT > factor()
	| "(" expresion() ")"
	| < tENTACAR > "(" expresion() ")"
	| < tCARAENT > "(" expresion() ")"
	| < tIDENTIFICADOR >
	| < tCONSTENTERA >
	| < tCONSTCHAR >
	| < tCONSTCAD >
	| < tTRUE >
	| < tFALSE >
*/
ExprRegister factor() :
{
  ExprRegister tpFactor, tpExpr, tpID, resultado;
  Token to;
  Simbolo s;
}
{
  try {
	  < tNOT > tpFactor = factor()
	  {
		if ((tpFactor.tipo != Tipo_variable.BOOLEANO)
			&& (tpFactor.tipo != Tipo_variable.DESCONOCIDO)) {
			error_semantico("Tipo incompatible. Se esperaba booleano");
		}

		// resultado.val_booleano = Boolean.parseBoolean(tpFactor.val_booleano); TODO?
		resultado.tipo  = Tipo_variable.BOOLEANO;
		return resultado;
	  }
	  
	| "-" tpFactor = factor()
	{
		if ((tpFactor.tipo != Tipo_variable.ENTERO)
			&& (tpFactor.tipo != Tipo_variable.DESCONOCIDO)) {
			error_semantico("Tipo incompatible. Se esperaba entero");
		}
		
		// resultado.val_entero = Integer.parseInteger(tpFactor.val_entero); TODO?
		resultado.tipo = Tipo_variable.ENTERO;
		return resultado;
	}
	| "(" tpExpr = expresion() ")"
	{
	  	return tpExpr;
	}
	| < tENTACAR > "(" tpExpr = expresion() ")"
	{
	  	if ((tpExpr.tipo != Tipo_variable.ENTERO)
	  		&& (tpExpr.tipo != Tipo_variable.DESCONOCIDO)) {
	  	  	error_semantico("Tipo incompatible. Se esperaba un entero para convertirlo a caracter");
	 	}

		resultado.val_char = (char)tpExpr.val_entero; // TODO: Convertir ya a caracter?????
	 	resultado.tipo = Tipo_variable.CHAR;
	 	return resultado;
	}
	| < tCARAENT > "(" expresion() ")"
	{
	  	if ((tpExpr.tipo != Tipo_variable.CHAR)
	  		&& (tpFactor.tipo != Tipo_variable.DESCONOCIDO)) {
	  	  	error_semantico("Tipo incompatible. Se esperaba un caracter para convertirlo a entero");
	 	}

	 	resultado.val_entero = (int)tpExpr.val_char; // TODO: Convertir ya a entero?????
	 	resultado.tipo = Tipo_variable.ENTERO;
	 	return resultado;
	}
	| to = < tIDENTIFICADOR >
	{
	  	s = ts.buscar_simbolo(to.image);
		
	  	if (s == null) {  // TODO: CAMBIAR PARA HANDELEAR EXCEPCIONES
	  		error_semantico("Identificador desconocido");
	  		tpID.tipo = Tipo_variable.DESCONOCIDO;
	 	}
	 	else {
	 	  	tpID.tipo = s.getVariable();
		}
		
		return tpID;
	}
	| to = < tCONSTENTERA >
	{
	  	resultado.val_entero = Integer.parseInt(to.image);
	  	resultado.tipo.ENTERO;
	  	return resultado;
	}
	| to = < tCONSTCHAR >
	{
	  	resultado.val_char = to.image.charAt(0);
	  	resultado.tipo.CHAR;
	  	return resultado;
	}
	| < tCONSTCAD > // TODO: Restricción semántica?? Pasar tipo?
	| to = < tTRUE >
	{
	  	resultado.val_booleano = Boolean.parseBoolean(to.image);
		resultado.tipo  = Tipo_variable.BOOLEANO;
		return resultado;
	}
	| < tFALSE > // TODO: (Factorizacion): Ver si se puede escribir una sola vez para TRUE y FALSE
	{
	  	resultado.val_booleano = Boolean.parseBoolean(to.image);
		resultado.tipo  = Tipo_variable.BOOLEANO;
		return resultado;
	}
  }
  catch(ParseException e) {
	error_sintactico(e.currentToken, e.expectedTokenSequences, e.tokenImage);

	Token t;
    do {
       t = getNextToken();
	} while (!SintacticoUtils.tokenEsperado(t, e.expectedTokenSequences) && t!=null && t.kind != EOF );
  }
}
